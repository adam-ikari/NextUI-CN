diff --git a/Makefile.libretro b/Makefile.libretro
index 6e974f5..ef2e692 100644
--- a/Makefile.libretro
+++ b/Makefile.libretro
@@ -93,8 +93,8 @@ ifneq (,$(findstring unix,$(platform)))
 else ifneq (,$(findstring trimui,$(platform)))
    TARGET := $(TARGET_NAME)_libretro.so
    fpic := -fPIC
-   SHARED := -shared -static-libgcc -static-libstdc++ -Wl,-no-undefined -Wl,-version-script=link.T
-   DEFINES += -std=c99 -D_GNU_SOURCE -DHAVE_LOCALE
+   SHARED := -shared -static-libgcc -static-libstdc++ -Wl,-no-undefined -Wl,-version-script=link.T -lpthread
+   DEFINES += -std=c99 -D_GNU_SOURCE -DHAVE_LOCALE -DUSE_THREAD
    CFLAGS += -Ofast -fno-ident
    CPUFLAGS := -march=armv7-a -mfpu=neon-vfpv4 -mfloat-abi=hard -marm
    CFLAGS += $(CPUFLAGS) -fpic -fomit-frame-pointer -fno-exceptions -fno-non-call-exceptions -Wno-psabi -Wno-format
diff --git a/include/mgba/internal/gba/audio.h b/include/mgba/internal/gba/audio.h
index 9cf6ded..0f20e0a 100644
--- a/include/mgba/internal/gba/audio.h
+++ b/include/mgba/internal/gba/audio.h
@@ -91,6 +91,7 @@ struct GBAAudio {
 
 	bool externalMixing;
 	struct GBAAudioMixer* mixer;
+	int outputSampleRate;
 };
 
 struct GBAMP2kADSR {
@@ -264,6 +265,7 @@ struct GBAAudioMixer {
 	bool (*engage)(struct GBAAudioMixer* mixer, uint32_t address);
 	void (*vblank)(struct GBAAudioMixer* mixer);
 	void (*step)(struct GBAAudioMixer* mixer);
+	void (*threadStep)(struct GBAAudioMixer* mixer);
 
 	struct GBAMP2kContext context;
 	struct GBAMP2kMusicPlayerInfo player;
@@ -273,6 +275,14 @@ struct GBAAudioMixer {
 	double frame;
 
 	struct mStereoSample last;
+
+#ifdef USE_THREAD
+	pthread_t audioThread;
+	bool threadRunning;
+	struct mCircleBuffer* sampleBuffer;
+	size_t bufferSize;
+	pthread_mutex_t bufferMutex;
+#endif
 };
 
 void GBAAudioMixerCreate(struct GBAAudioMixer* mixer);
diff --git a/src/gba/audio-mixer.c b/src/gba/audio-mixer.c
index 8cd38eb..2f32998 100644
--- a/src/gba/audio-mixer.c
+++ b/src/gba/audio-mixer.c
@@ -8,6 +8,10 @@
 #include <mgba/internal/gba/gba.h>
 #include <mgba/internal/gba/video.h>
 
+#ifdef USE_THREAD
+#include <pthread.h>
+#endif
+
 #define OVERSAMPLE 2
 
 static void _mp2kInit(void* cpu, struct mCPUComponent* component);
@@ -16,6 +20,11 @@ static void _mp2kDeinit(struct mCPUComponent* component);
 static bool _mp2kEngage(struct GBAAudioMixer* mixer, uint32_t address);
 static void _mp2kVblank(struct GBAAudioMixer* mixer);
 static void _mp2kStep(struct GBAAudioMixer* mixer);
+static void _mp2kThreadStep(struct GBAAudioMixer* mixer);
+
+#ifdef USE_THREAD
+static void* _audioThread(void* arg);
+#endif
 
 void GBAAudioMixerCreate(struct GBAAudioMixer* mixer) {
 	memset(mixer, 0, sizeof(*mixer));
@@ -24,6 +33,7 @@ void GBAAudioMixerCreate(struct GBAAudioMixer* mixer) {
 	mixer->engage = _mp2kEngage;
 	mixer->vblank = _mp2kVblank;
 	mixer->step = _mp2kStep;
+	mixer->threadStep = _mp2kThreadStep;
 }
 
 void _mp2kInit(void* cpu, struct mCPUComponent* component) {
@@ -40,6 +50,13 @@ void _mp2kInit(void* cpu, struct mCPUComponent* component) {
 	memset(&mixer->context, 0, sizeof(mixer->context));
 	memset(&mixer->activeTracks, 0, sizeof(mixer->activeTracks));
 
+#ifdef USE_THREAD
+	mixer->threadRunning = false;
+	mixer->sampleBuffer = NULL;
+	mixer->bufferSize = 8192;
+	pthread_mutex_init(&mixer->bufferMutex, NULL);
+#endif
+
 	size_t i;
 	for (i = 0; i < MP2K_MAX_SOUND_CHANNELS; ++i) {
 		mixer->activeTracks[i].channel = &mixer->context.chans[i];
@@ -49,6 +66,19 @@ void _mp2kInit(void* cpu, struct mCPUComponent* component) {
 
 void _mp2kDeinit(struct mCPUComponent* component) {
 	struct GBAAudioMixer* mixer = (struct GBAAudioMixer*) component;
+
+#ifdef USE_THREAD
+	if (mixer->threadRunning) {
+		mixer->threadRunning = false;
+		pthread_join(mixer->audioThread, NULL);
+	}
+	if (mixer->sampleBuffer) {
+		mCircleBufferDeinit(mixer->sampleBuffer);
+		free(mixer->sampleBuffer);
+	}
+	pthread_mutex_destroy(&mixer->bufferMutex);
+#endif
+
 	size_t i;
 	for (i = 0; i < MP2K_MAX_SOUND_CHANNELS; ++i) {
 		mCircleBufferDeinit(&mixer->activeTracks[i].buffer);
@@ -116,13 +146,14 @@ static void _stepSample(struct GBAAudioMixer* mixer, struct GBAMP2kTrack* track)
 		return;
 	}
 	uint32_t loopOffset = memory->load32(cpu, headerAddress + 0x8, 0);
-	uint32_t endOffset = memory->load32(cpu, headerAddress + 0xC, 0);
-	uint32_t sampleBase = headerAddress + 0x10;
-	uint32_t sampleI = track->samplePlaying;
-	double sampleOffset = track->currentOffset;
-	double updates = VIDEO_TOTAL_LENGTH / (mixer->tempo * mixer->p->sampleInterval / OVERSAMPLE);
-	int nSample;
-	for (nSample = 0; nSample < updates; ++nSample) {
+			uint32_t endOffset = memory->load32(cpu, headerAddress + 0xC, 0);
+			uint32_t sampleBase = headerAddress + 0x10;
+			uint32_t sampleI = track->samplePlaying;
+			double sampleOffset = track->currentOffset;
+			// Use 48kHz for XQ audio mixing instead of GBA sample rate
+			double xqSampleInterval = GBA_ARM7TDMI_FREQUENCY / 48000;
+			double updates = VIDEO_TOTAL_LENGTH / (mixer->tempo * xqSampleInterval / OVERSAMPLE);
+			int nSample;	for (nSample = 0; nSample < updates; ++nSample) {
 		int8_t sample = memory->load8(cpu, sampleBase + sampleI, 0);
 
 		struct GBAStereoSample stereo = {
@@ -257,7 +288,9 @@ bool _mp2kEngage(struct GBAAudioMixer* mixer, uint32_t address) {
 }
 
 void _mp2kStep(struct GBAAudioMixer* mixer) {
-	mixer->frame += mixer->p->sampleInterval;
+	// Use 48kHz for XQ audio mixing
+	double xqSampleInterval = GBA_ARM7TDMI_FREQUENCY / 48000;
+	mixer->frame += xqSampleInterval;
 
 	while (mixer->frame >= VIDEO_TOTAL_LENGTH / mixer->tempo) {
 		int i;
@@ -274,7 +307,7 @@ void _mp2kStep(struct GBAAudioMixer* mixer) {
 		mixer->frame -= VIDEO_TOTAL_LENGTH / mixer->tempo;
 	}
 
-	uint32_t interval = mixer->p->sampleInterval / OVERSAMPLE;
+	uint32_t interval = xqSampleInterval / OVERSAMPLE;
 	int i;
 	for (i = 0; i < OVERSAMPLE; ++i) {
 		struct mStereoSample sample = {0};
@@ -293,6 +326,56 @@ void _mp2kStep(struct GBAAudioMixer* mixer) {
 	}
 }
 
+#ifdef USE_THREAD
+static void* _audioThread(void* arg) {
+	struct GBAAudioMixer* mixer = (struct GBAAudioMixer*) arg;
+	struct mTiming* timing = &mixer->p->p->timing;
+
+	while (mixer->threadRunning) {
+		pthread_mutex_lock(&mixer->bufferMutex);
+
+		size_t available = mCircleBufferCapacity(mixer->sampleBuffer) - mCircleBufferSize(mixer->sampleBuffer);
+		if (available >= 2) {
+			for (size_t i = 0; i < 2; ++i) {
+				_mp2kStep(mixer);
+				mCircleBufferWrite16(mixer->sampleBuffer, mixer->last.left);
+				mCircleBufferWrite16(mixer->sampleBuffer, mixer->last.right);
+			}
+		}
+
+		pthread_mutex_unlock(&mixer->bufferMutex);
+
+		usleep(10000);
+	}
+
+	return NULL;
+}
+
+void _mp2kThreadStep(struct GBAAudioMixer* mixer) {
+	if (!mixer->threadRunning) {
+		mixer->sampleBuffer = malloc(sizeof(struct mCircleBuffer));
+		mCircleBufferInit(mixer->sampleBuffer, mixer->bufferSize);
+		mixer->threadRunning = true;
+		pthread_create(&mixer->audioThread, NULL, _audioThread, mixer);
+	}
+
+	pthread_mutex_lock(&mixer->bufferMutex);
+
+	if (mCircleBufferSize(mixer->sampleBuffer) >= 2) {
+		int16_t left, right;
+		mCircleBufferRead16(mixer->sampleBuffer, &left);
+		mCircleBufferRead16(mixer->sampleBuffer, &right);
+		mixer->last.left = left;
+		mixer->last.right = right;
+	} else {
+		mixer->last.left = 0;
+		mixer->last.right = 0;
+	}
+
+	pthread_mutex_unlock(&mixer->bufferMutex);
+}
+#endif
+
 void _mp2kVblank(struct GBAAudioMixer* mixer) {
 	if (!mixer->contextAddress) {
 		return;
diff --git a/src/gba/audio.c b/src/gba/audio.c
index a3de77e..82e984a 100644
--- a/src/gba/audio.c
+++ b/src/gba/audio.c
@@ -13,6 +13,11 @@
 #include <mgba/internal/gba/serialize.h>
 #include <mgba/internal/gba/video.h>
 
+#ifdef USE_THREAD
+#include <pthread.h>
+#include <unistd.h>
+#endif
+
 #define MP2K_LOCK_MAX 8
 
 mLOG_DEFINE_CATEGORY(GBA_AUDIO, "GBA Audio", "gba.audio");
@@ -47,6 +52,7 @@ void GBAAudioInit(struct GBAAudio* audio, size_t samples) {
 
 	audio->externalMixing = false;
 	audio->mixer = NULL;
+	audio->outputSampleRate = GBA_ARM7TDMI_FREQUENCY / audio->sampleInterval;
 }
 
 void GBAAudioEnableMixer(struct GBAAudio* audio, struct GBAAudioMixer* mixer) {
@@ -66,6 +72,15 @@ void GBAAudioEnableMixer(struct GBAAudio* audio, struct GBAAudioMixer* mixer) {
 		mixer->activeTracks[i].channel = &mixer->context.chans[i];
 		mCircleBufferInit(&mixer->activeTracks[i].buffer, 0x10000);
 	}
+
+	// Change sample rate to 48kHz when XQ audio is enabled
+	audio->sampleInterval = GBA_ARM7TDMI_FREQUENCY / 48000;
+	audio->outputSampleRate = 48000;
+	
+	// Notify core about sample rate change
+	if (audio->p && audio->p->stream && audio->p->stream->audioRateChanged) {
+		audio->p->stream->audioRateChanged(audio->p->stream, audio->outputSampleRate);
+	}
 }
 
 void GBAAudioReset(struct GBAAudio* audio) {
@@ -106,10 +121,15 @@ void GBAAudioReset(struct GBAAudio* audio) {
 	audio->enable = false;
 
 	if (audio->sampleInterval != GBA_ARM7TDMI_FREQUENCY / 0x8000) {
+		// Sample rate was changed (likely by XQ audio), keep it
+		audio->outputSampleRate = GBA_ARM7TDMI_FREQUENCY / audio->sampleInterval;
+	} else {
 		audio->sampleInterval = GBA_ARM7TDMI_FREQUENCY / 0x8000;
-		if (audio->p->stream && audio->p->stream->audioRateChanged) {
-			audio->p->stream->audioRateChanged(audio->p->stream, GBA_ARM7TDMI_FREQUENCY / audio->sampleInterval);
-		}
+		audio->outputSampleRate = GBA_ARM7TDMI_FREQUENCY / audio->sampleInterval;
+	}
+	
+	if (audio->p->stream && audio->p->stream->audioRateChanged) {
+		audio->p->stream->audioRateChanged(audio->p->stream, audio->outputSampleRate);
 	}
 	audio->psg.sampleInterval = audio->sampleInterval;
 }
@@ -374,15 +394,32 @@ static int _applyBias(struct GBAAudio* audio, int sample) {
 void GBAAudioSample(struct GBAAudio* audio, int32_t timestamp) {
 	if (audio->externalMixing && audio->mixer && audio->mixer->step) {
 		int maxSample = 2 << GBARegisterSOUNDBIASGetResolution(audio->soundbias);
-
-		// Call mixer step to update internal state
-		audio->mixer->step(audio->mixer);
-
-		// Get the last sample from the mixer
-		for (int i = 0; i < maxSample; ++i) {
+		int samplesNeeded = maxSample;
+
+#ifdef USE_THREAD
+		// Use thread-based mixing if available
+		if (audio->mixer->threadStep) {
+			for (int i = 0; i < samplesNeeded; ++i) {
+				audio->mixer->threadStep(audio->mixer);
+				audio->currentSamples[i].left = audio->mixer->last.left;
+				audio->currentSamples[i].right = audio->mixer->last.right;
+			}
+		} else {
+			// Fallback to synchronous mixing
+			for (int i = 0; i < samplesNeeded; ++i) {
+				audio->mixer->step(audio->mixer);
+				audio->currentSamples[i].left = audio->mixer->last.left;
+				audio->currentSamples[i].right = audio->mixer->last.right;
+			}
+		}
+#else
+		// For 48kHz output, call mixer step for each sample
+		for (int i = 0; i < samplesNeeded; ++i) {
+			audio->mixer->step(audio->mixer);
 			audio->currentSamples[i].left = audio->mixer->last.left;
 			audio->currentSamples[i].right = audio->mixer->last.right;
 		}
+#endif
 
 		audio->sampleIndex = maxSample;
 		audio->lastSample += SAMPLE_INTERVAL;
